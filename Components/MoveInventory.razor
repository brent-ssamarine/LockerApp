@using LockerApp.Models.ViewModels
@using LockerApp.Models.LockerDB
@using Microsoft.EntityFrameworkCore
@using LockerApp.Data.LockerDB
@using LockerApp.Services
@inject IServiceProvider ServiceProvider
@inject LockerService LockerService

<style>
    .location-select option {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
</style>

@if (Show)
{
    <div class="modal fade show" style="display: block" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header bg-primary text-white">
                    <h5 class="modal-title">Move Inventory</h5>
                    <button type="button" class="btn-close btn-close-white" @onclick="OnClose"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label class="form-label">Item</label>
                        <input type="text" class="form-control" value="@ItemName" readonly />
                    </div>
                    
                    <div class="mb-3">
                        <div class="d-flex">
                            <div class="flex-grow-1">
                                <input type="text" class="form-control" value="@Quantity" readonly />
                            </div>
                            <div class="ms-2">
                                <span>@("@ " + FromLocation)</span>
                            </div>
                        </div>
                    </div>

                    <div class="mb-3">
                        <label class="form-label">Note</label>
                        <input type="text" class="form-control" @bind="Note" />
                    </div>

                    <div class="row g-3 mb-3">
                        <div class="col-md-6">
                            <label class="form-label">Transfer</label>
                            <div class="d-flex">
                                <input type="number" class="form-control" @bind="TransferQuantity" />
                                <span class="ms-2">to</span>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <label class="form-label">&nbsp;</label>
                            <select class="form-select location-select" @bind="ToLocation">
                                <option value="">Select...</option>
                                @if (locations != null)
                                {
                                    @foreach (var loc in locations)
                                    {
                                        <option value="@loc.Id">@loc.Id.ToString().PadRight(5, '\u00A0')â”‚ @loc.Name</option>
                                    }
                                }
                            </select>
                        </div>
                    </div>

                    <div class="row g-3 mb-3">
                        <div class="col-md-6">
                            <label class="form-label">Taken From</label>
                            <select class="form-select" @bind="TakenFrom">
                                <option value="">Select...</option>
                                @if (takenFromOptions != null)
                                {
                                    @foreach (var type in takenFromOptions)
                                    {
                                        <option value="@type">@type</option>
                                    }
                                }
                            </select>
                        </div>
                        <div class="col-md-6">
                            <label class="form-label">as of</label>
                            <select class="form-select" @bind="SelectedAsOfDateString">
                                <option value="">Select...</option> // Added this line
                                @if (asOfDateOptions != null && asOfDateOptions.Any())
                                {
                                    @foreach (var dateStr in asOfDateOptions)
                                    {
                                        <option value="@dateStr">@dateStr</option>
                                    }
                                }
                                else if (asOfDateOptions != null) // Only show if list is initialized but empty
                                {
                                    <option value="" disabled>No dates available</option>
                                }
                                else // asOfDateOptions is null (still loading or error before list initialization)
                                {
                                    <option value="" disabled>Loading dates...</option>
                                }
                            </select>
                        </div>
                    </div>

                    <div class="mb-3">
                        <label class="form-label">Inspected By</label>
                        <textarea class="form-control" @bind="InspectedBy" rows="2"></textarea>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary" @onclick="HandleMove" disabled="@isProcessing">
                        @if (isProcessing)
                        {
                            <span class="spinner-border spinner-border-sm me-1" role="status"></span>
                        }
                        Move
                    </button>
                    <button type="button" class="btn btn-secondary" @onclick="OnClose" disabled="@isProcessing">Close</button>
                </div>
            </div>
        </div>
    </div>
    <div class="modal-backdrop fade show"></div>
}

@code {
    // Debug control - set to false to reduce console output
    private const bool EnableDebugLogging = true;
    
    private void DebugLog(string message)
    {
        if (EnableDebugLogging)
        {
            Console.WriteLine(message);
        }
    }

    [Parameter]
    public bool Show { get; set; }

    [Parameter]
    public EventCallback<bool> ShowChanged { get; set; }

    [Parameter]
    public string ItemName { get; set; } = "";

    [Parameter]
    public string ItemId { get; set; } = "";

    [Parameter]
    public string FromLocation { get; set; } = "";

    [Parameter]
    public int FromLocationId { get; set; }

    [Parameter]
    public double Quantity { get; set; }

    [Parameter]
    public EventCallback<bool> OnMoveCompleted { get; set; }

    [Parameter]
    public string Description { get; set; } = "";
    
    private string Note { get; set; } = "";
    private double TransferQuantity { get; set; }
    private double CostPer { get; set; }
    private string? PONumber { get; set; }
    private string? ToLocation { get; set; }
    private string? TakenFrom { get; set; }
    private DateTime AsOfDate { get; set; } = DateTime.Today;
    private string InspectedBy { get; set; } = "";
    private List<LocationViewModel>? locations;
    private List<string>? takenFromOptions;
    private List<string>? asOfDateOptions;
    private bool isProcessing = false;

    private string? _selectedAsOfDateString;
    private string? SelectedAsOfDateString
    {
        get => _selectedAsOfDateString;
        set
        {
            _selectedAsOfDateString = value;
            if (DateTime.TryParseExact(value, "MM/dd/yyyy", System.Globalization.CultureInfo.InvariantCulture, System.Globalization.DateTimeStyles.None, out var parsedDate))
            {
                AsOfDate = parsedDate;
            }
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        Console.WriteLine("=== DEBUG: OnParametersSetAsync() started ===");
        Console.WriteLine($"DEBUG: Parameters - ItemName: '{ItemName}', ItemId: '{ItemId}', FromLocationId: {FromLocationId}, FromLocation: '{FromLocation}', Quantity: {Quantity}, Description: '{Description}'");
        
        Note = Description ?? string.Empty;
        TransferQuantity = Quantity;
        ToLocation = null;
        TakenFrom = null;
        
        Console.WriteLine("DEBUG: Loading locations...");
        await LoadLocations();
        Console.WriteLine($"DEBUG: Loaded {locations?.Count ?? 0} locations");
        
        Console.WriteLine("DEBUG: Loading taken from options...");
        await LoadTakenFromOptionsAsync();
        Console.WriteLine($"DEBUG: Loaded {takenFromOptions?.Count ?? 0} taken from options");
        
        Console.WriteLine("DEBUG: Loading as of date options...");
        await LoadAsOfDateOptionsAsync();
        Console.WriteLine($"DEBUG: Loaded {asOfDateOptions?.Count ?? 0} date options");

        SelectedAsOfDateString = null;
        AsOfDate = default;
        Console.WriteLine("=== DEBUG: OnParametersSetAsync() completed ===");
    }

    private async Task LoadLocations()
    {
        try
        {
            using var scope = ServiceProvider.CreateScope();
            var dbContext = scope.ServiceProvider.GetRequiredService<LockerDbContext>();

            locations = await dbContext.Locations
                .Where(l => l.Id != FromLocationId &&
                           l.Finished != 1 &&
                           l.LocationType != "SUPPLIER" &&
                           l.LocationType != null)
                .OrderBy(l => l.Name)
                .Select(l => new LocationViewModel 
                { 
                    Id = l.Id,
                    Name = l.Name ?? ""
                })
                .ToListAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading locations: {ex.Message}");
        }
    }

    private async Task LoadTakenFromOptionsAsync()
    {
        try
        {
            using var scope = ServiceProvider.CreateScope();
            var dbContext = scope.ServiceProvider.GetRequiredService<LockerDbContext>();

            var locationTypes = await dbContext.Locations
                .Select(l => l.LocationType)
                .Where(lt => lt != null)
                .Distinct()
                .ToListAsync();

            takenFromOptions = new List<string>();
            takenFromOptions.AddRange(locationTypes.Where(lt => lt != null)!);
            takenFromOptions = takenFromOptions.OrderBy(x => x).ToList();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading 'Taken From' options: {ex.Message}");
            takenFromOptions = new List<string> { "STOCK", "RENTAL", "Error Loading Types" };
        }
    }

    private async Task LoadAsOfDateOptionsAsync()
    {
        try
        {
            using var scope = ServiceProvider.CreateScope();
            var dbContext = scope.ServiceProvider.GetRequiredService<LockerDbContext>();

            var dates = await dbContext.TwoWeeks
                .Select(t => t.SelectDate)
                .Distinct()
                .OrderByDescending(d => d)
                .Select(d => d.ToString("MM/dd/yyyy"))
                .ToListAsync();

            var today = DateTime.Today.ToString("MM/dd/yyyy");
            if (!dates.Contains(today))
            {
                dates.Insert(0, today);
            }

            if (!dates.Any())
            {
                dates.Add(today);
            }

            asOfDateOptions = dates;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading 'as of' date options: {ex.Message}");
            asOfDateOptions = new List<string> { DateTime.Today.ToString("MM/dd/yyyy") };
        }
    }

    private async Task HandleMove()
    {
        DebugLog("=== DEBUG: HandleMove() started ===");
        DebugLog($"DEBUG: Component Parameters - ItemId: '{ItemId}', ItemName: '{ItemName}', FromLocationId: {FromLocationId}, FromLocation: '{FromLocation}', Quantity: {Quantity}");
        
        // Validate required fields (matching VBA validation)
        DebugLog($"DEBUG: Form Values - ToLocation: '{ToLocation}', TakenFrom: '{TakenFrom}', AsOfDate: '{AsOfDate}', TransferQuantity: {TransferQuantity}, Note: '{Note}', InspectedBy: '{InspectedBy}'");
        
        if (string.IsNullOrEmpty(ToLocation) || string.IsNullOrEmpty(TakenFrom) || AsOfDate == default)
        {
            DebugLog("DEBUG: Validation failed - missing required fields");
            var missingFields = new List<string>();
            if (string.IsNullOrEmpty(ToLocation)) missingFields.Add("ToLocation");
            if (string.IsNullOrEmpty(TakenFrom)) missingFields.Add("TakenFrom");
            if (AsOfDate == default) missingFields.Add("AsOfDate");
            DebugLog($"DEBUG: Missing fields: {string.Join(", ", missingFields)}");
            Console.WriteLine("Please fill in all fields before transferring inventory");
            return;
        }

        DebugLog($"DEBUG: Validating quantity - TransferQuantity: {TransferQuantity}, Original Quantity: {Quantity}");
        if (TransferQuantity <= 0)
        {
            Console.WriteLine("DEBUG: Validation failed - invalid transfer quantity");
            Console.WriteLine("Transfer quantity must be greater than 0");
            return;
        }

        Console.WriteLine("DEBUG: All validations passed, starting processing");
        isProcessing = true;
        StateHasChanged();

        try
        {
            Console.WriteLine("DEBUG: Starting database operations");
            using var scope = ServiceProvider.CreateScope();
            var dbContext = scope.ServiceProvider.GetRequiredService<LockerDbContext>();
            Console.WriteLine("DEBUG: Database context created successfully");

            // Disable change tracking for this context
            dbContext.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;

            // Get the FROM inventory location record
            var fromRecord = await dbContext.InventoryLocations
                .AsNoTracking()
                .FirstOrDefaultAsync(il => il.Id == FromLocationId);

            if (fromRecord == null)
            {
                Console.WriteLine($"ERROR: No inventory found for ID: {FromLocationId}");
                return;
            }
            
            // Create a new instance to avoid tracking
            fromRecord = new InventoryLocation
            {
                Id = fromRecord.Id,
                ItemId = fromRecord.ItemId,
                ItemName = fromRecord.ItemName,
                LocationId = fromRecord.LocationId,
                Description = fromRecord.Description,
                Issued = fromRecord.Issued,
                OnHand = fromRecord.OnHand,
                Billable = fromRecord.Billable
            };

            Console.WriteLine($"DEBUG: Found FROM record - ID: {fromRecord.Id}, Item: '{fromRecord.ItemId}', ItemName: '{fromRecord.ItemName}', LocationId: {fromRecord.LocationId}, OnHand: {fromRecord.OnHand}");

            // Validate sufficient quantity
            if (fromRecord.OnHand < TransferQuantity)
            {
                Console.WriteLine($"ERROR: Insufficient quantity - Available: {fromRecord.OnHand}, Requested: {TransferQuantity}");
                Console.WriteLine($"Insufficient quantity available. Only {fromRecord.OnHand} units available.");
                return;
            }

            // Check if a TO record already exists for this item at the destination location
            var toLocationId = int.Parse(ToLocation);
            Console.WriteLine($"DEBUG: Looking for TO record - ItemId: '{fromRecord.ItemId}', LocationId: {toLocationId}");
            
            // Get the existing record without tracking
            var existingToRecord = await dbContext.InventoryLocations
                .AsNoTracking()
                .FirstOrDefaultAsync(il => il.ItemId == fromRecord.ItemId && il.LocationId == toLocationId);
                
            // Declare and initialize toRecord with a new instance if needed
            InventoryLocation? toRecord = null;
                
            if (existingToRecord == null)
            {
                Console.WriteLine("DEBUG: TO record not found, creating new inventory location");
                
                // Use raw SQL approach directly to avoid Entity Framework trigger issues
                try
                {
                    // Insert the record without OUTPUT clause (invloc_id will be auto-generated as IDENTITY)
                    var insertSql = @"
                        INSERT INTO [dbo].[inventory_locations] ([item], [item_name], [description], [billable], [location], [onhand], [issued])
                        VALUES (@p0, @p1, @p2, @p3, @p4, @p5, @p6)";
                        
                    var parameters = new object[] { 
                        fromRecord.ItemId ?? "", 
                        fromRecord.ItemName ?? "", 
                        fromRecord.Description ?? "", 
                        fromRecord.Billable ?? 0, 
                        toLocationId, 
                        0.0, 
                        0.0 
                    };
                    
                    Console.WriteLine("DEBUG: Executing raw SQL to create TO record (avoiding Entity Framework trigger conflicts)");
                    var rowsAffected = await dbContext.Database.ExecuteSqlRawAsync(insertSql, parameters);
                    
                    if (rowsAffected > 0)
                    {
                        Console.WriteLine($"DEBUG: Insert successful, {rowsAffected} rows affected");
                        
                        // Find the newly created record
                        var newToRecord = await dbContext.InventoryLocations
                            .AsNoTracking()
                            .Where(il => il.ItemId == fromRecord.ItemId && il.LocationId == toLocationId)
                            .OrderByDescending(il => il.Id) // Get the most recent one
                            .FirstOrDefaultAsync();
                            
                        if (newToRecord == null)
                        {
                            Console.WriteLine("ERROR: Failed to find newly created TO record");
                            return;
                        }
                        
                        // Create a new instance to avoid tracking
                        toRecord = new InventoryLocation
                        {
                            Id = newToRecord.Id,
                            ItemId = newToRecord.ItemId,
                            ItemName = newToRecord.ItemName,
                            LocationId = newToRecord.LocationId,
                            Description = newToRecord.Description,
                            Issued = newToRecord.Issued,
                            OnHand = newToRecord.OnHand,
                            Billable = newToRecord.Billable
                        };
                        Console.WriteLine($"DEBUG: Found newly created TO record - ID: {toRecord.Id}, OnHand: {toRecord.OnHand}");
                    }
                    else
                    {
                        Console.WriteLine("ERROR: Raw SQL insertion did not affect any rows");
                        return;
                    }
                }
                catch (Exception sqlException)
                {
                    Console.WriteLine($"ERROR: Raw SQL creation failed: {sqlException.Message}");
                    Console.WriteLine("ERROR: Unable to create inventory location record at destination");
                    return;
                }
            }
            else if (existingToRecord != null)
            {
                // Create a new instance to avoid tracking
                toRecord = new InventoryLocation
                {
                    Id = existingToRecord.Id,
                    ItemId = existingToRecord.ItemId,
                    ItemName = existingToRecord.ItemName,
                    LocationId = existingToRecord.LocationId,
                    Description = existingToRecord.Description,
                    Issued = existingToRecord.Issued,
                    OnHand = existingToRecord.OnHand,
                    Billable = existingToRecord.Billable
                };
                Console.WriteLine($"DEBUG: Found existing TO record - ID: {toRecord.Id}, OnHand: {toRecord.OnHand}, LocationId: {toRecord.LocationId}");
            }

            if (toRecord == null)
            {
                Console.WriteLine("ERROR: Failed to initialize TO record");
                return;
            }

            Console.WriteLine("DEBUG: Creating inventory transfer record");
            Console.WriteLine($"DEBUG: Transfer details - Quantity: {TransferQuantity}, FromLocationID: {fromRecord.Id}, ToLocationID: {toRecord.Id}, Company: WES, Job: MOVE, TakenFrom: {TakenFrom}, Date: {AsOfDate:yyyy-MM-dd}");
            
            // Create the transfer record using the service provider to create a new scope
            await LockerService.WriteInventoryTransferAsync(
                TransferQuantity,  // quantity
                Note,              // description
                fromRecord,        // fromLocation
                toRecord,          // toLocation
                "WES",             // company
                "MOVE",            // job
                TakenFrom,         // takenFrom
                AsOfDate,          // transferDate
                PONumber,          // poNumber
                CostPer,           // costPer
                0,                 // lockerTotal
                toRecord.OnHand ?? 0, // inventoryTotal
                InspectedBy,       // inspectedBy
                ServiceProvider    // serviceProvider
            );
            Console.WriteLine("DEBUG: Inventory transfer record created");

            Console.WriteLine("DEBUG: Updating inventory locations");
            Console.WriteLine($"DEBUG: BEFORE Update - FROM OnHand: {fromRecord.OnHand}, TO OnHand: {toRecord.OnHand}");
            
            // Update inventory locations using LockerService with transaction handling
            // This will update the OnHand values, save changes, and handle transactions
            try
            {
                await LockerService.UpdateInventoryLocationsAsync(
                    TransferQuantity,
                    fromRecord,
                    toRecord,
                    ServiceProvider  // Pass service provider for proper scope handling
                );
                Console.WriteLine("DEBUG: Inventory locations updated and committed successfully");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"ERROR: Failed to update inventory locations: {ex.Message}");
                if (ex.InnerException != null)
                {
                    Console.WriteLine($"INNER EXCEPTION: {ex.InnerException.Message}");
                }
                throw;
            }

            Console.WriteLine("DEBUG: Transfer completed successfully, triggering callbacks");
            await OnMoveCompleted.InvokeAsync(true);
            await OnClose();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ERROR: Exception during inventory transfer: {ex.Message}");
            Console.WriteLine($"ERROR: Stack trace: {ex.StackTrace}");
            // TODO: Show error message to user
        }
        finally
        {
            Console.WriteLine("DEBUG: Cleaning up - setting isProcessing to false");
            isProcessing = false;
            StateHasChanged();
        }
        
        Console.WriteLine("=== DEBUG: HandleMove() completed ===");
    }

    private async Task OnClose()
    {
        Show = false;
        await ShowChanged.InvokeAsync(Show);
    }
} 